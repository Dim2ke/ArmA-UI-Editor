using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SQF.ClassParser;

COMPILER CONFIGFILE
	CHARACTERS
		DIGIT = "0123456789".
        HEXDIGIT = "0123456789ABCDEFabcdef".
		CHARACTER = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".
        ACHARACTER = "!|§$%&/*+-()=?`´#~ß}][{-_".
		OTHER = ANY - '/' - '*'. 
		STRINGCHARS = ANY - '\n' - '\r' - '"'.

	TOKENS
		T_SCALAR = [ '-' ] DIGIT { DIGIT } [ '.' DIGIT { DIGIT } ].
        T_HEX = ("0x" | "0X") HEXDIGIT { HEXDIGIT }.
		T_STRING = '"' { STRINGCHARS | "\\\""} '"'.
        T_STRINGTABLESTRING = '$' { CHARACTER | '_' | DIGIT }.
		T_IDENT = ( CHARACTER | '_' ) { CHARACTER | '_' | DIGIT }.
		
	COMMENTS FROM "/*" TO "*/" NESTED
	COMMENTS FROM "//" TO '\n'
	COMMENTS FROM '#' TO '\n'
	IGNORE '\t' + '\r' + '\n'
		
	PRODUCTIONS
		CONFIGFILE (. Data data; .) =
            (.
            if(Base == null)
            {
                Base = new SQF.ClassParser.File();
            }
            StringList PathList = new StringList();
            .)
            
            
            CONFIG<out data, Base, PathList> (. Base[data] = data; .)
            {
                CONFIG<out data, Base, PathList> (. Base[data] = data; .)
            }
		.
        CONFIG<out Data data, ConfigClass parent, StringList PathList> (. ConfigClass cc = new ConfigClass(); data = new Data(cc); Data d; .) =
            "class"
            T_IDENT
            (.
                if(parent.ContainsKey(t.val))
                {
                    SemErr("Class is already defined in current scope");
                }
                data.Name = t.val;
            .)
            [
                ':'
                T_IDENT
                (.
                    ConfigClass c = parent;
                    var tmpList = new StringList(PathList);
                    Data tmpData = null;
                    do
                    {
                        StringBuilder sb = new StringBuilder();
                        foreach (var it in tmpList)
                        {
                            sb.Append('/');
                            sb.Append(it);
                        };
                        sb.Append('/');
                        sb.Append(t.val);
                        tmpData = this.Base[sb.ToString()];
                        if (tmpList.Count == 0)
                            break;
                        tmpList.RemoveAt(tmpList.Count - 1);
                    } while (tmpData == null || !tmpData.IsClass);
                    
                    if (c != null)
                    {
                        cc.Parent = tmpData;
                    }
                    else
                    {
                        SemErr("Parent is not yet existing");
                    };
                .)
            ]
            (. PathList.Add(data.Name); .)
            [
                '{'
                {
                    FIELD<out d> (. data.Class[d] = d; .)
                    |
                    CONFIG<out d, data.Class, PathList> (. data.Class[d] = d; .)
                }
                '}'
            ]
            ';'
            (. PathList.RemoveAt(PathList.Count - 1); .)
        .
        FIELD<out Data data> (. data = null; bool isArray = false; .) =
            T_IDENT (. string name = t.val; .)
            [
                '['
                ']'
                (. isArray = true; .)
            ]
            '='
            (
                ARRAY<out data> (. if(!isArray) SemErr("Invalid field syntax: Missing [] at field name"); .)
                |
                SCALAR<out data> (. if(isArray) SemErr("Invalid field syntax: Located [] at field name"); .)
                |
                STRING<out data> (. if(isArray) SemErr("Invalid field syntax: Located [] at field name"); .)
                |
                BOOLEAN<out data> (. if(isArray) SemErr("Invalid field syntax: Located [] at field name"); .)
            )
            ';'
            (. if(data != null) data.Name = name; .)
        .
        SCALAR<out Data data> (. data = null; .)  =
            T_SCALAR (. data = new Data(Double.Parse(t.val, System.Globalization.CultureInfo.InvariantCulture)); .)
            |
            T_HEX (. data = new Data((double)Convert.ToInt32(t.val.Substring(2), 16)); .)
        .
        STRING<out Data data> (. string content = default(string); .) = 
            (
                T_STRING (. content = t.val.Substring(1, t.val.Length - 2); .)
                |
                T_STRINGTABLESTRING (. content = t.val.Substring(1); .)
            )
            (.
            //TODO: Add ArmA like string escaping
            data = new Data(content);
            .)
        .
        BOOLEAN<out Data data> (. bool flag = false; .) =
            (
                "true" (. flag = true; .)
                |
                "false"
            )
            (.
            data = new Data(flag);
            .)
        .
        ARRAY<out Data data> (. data = new Data(new List<Data>()); Data tmp; .) = 
            '{'
            (
                SCALAR<out tmp> (. data.Array.Add(tmp); .)
                |
                STRING<out tmp> (. data.Array.Add(tmp); .)
                |
                BOOLEAN<out tmp> (. data.Array.Add(tmp); .)
            )
            {
                ','
                (
                    SCALAR<out tmp> (. data.Array.Add(tmp); .)
                    |
                    STRING<out tmp> (. data.Array.Add(tmp); .)
                    |
                    BOOLEAN<out tmp> (. data.Array.Add(tmp); .)
                )
            }
            '}'
        .
END CONFIGFILE.